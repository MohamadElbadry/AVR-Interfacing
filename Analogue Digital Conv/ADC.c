
#include <avr/interrupt.h>
#include "util.h"
#include "Registers.h"
#include "ADC.h"


void Adc_Init(void)
{
	//ADC ENABLE
	SET_BIT(REG_ADCSRA,7);


	// ADC AREF
#if ADC_AREF==ENABLE
	CLEAR_BIT(REG_ADMUX,7);
	CLEAR_BIT(REG_ADMUX,6);

	// AVCC = Internal VCC
#elif ADC_AVCC==ENABLE
	CLEAR_BIT(REG_ADMUX,7);
	SET_BIT(REG_ADMUX,6);

	// Internal v = 2.56 volt
#elif ADC_INTERN==ENABLE
	SET_BIT(REG_ADMUX,7);
	SET_BIT(REG_ADMUX,6);
#endif

	// ADC ADJUSTMENT
#if ADC_ADJUST==RIGHT
	CLEAR_BIT(REG_ADMUX,5);

#elif ADC_ADJUST==LEFT
	SET_BIT(REG_ADMUX,5);

#endif



	// We use polling not interept
#if INTEREPT==ENABLE
	CLEAR_BIT(REG_ADCSRA,3);
#endif


	//ADC MODE
#if ADC_TRIGGER==FREE_RUNNING  //single mode  // no trigger is used
	CLEAR_BIT(REG_SFIOR,5);
	CLEAR_BIT(REG_SFIOR,6);
	CLEAR_BIT(REG_SFIOR,7);

#elif ADC_TRIGGER== ANALOGUE_COMPARATOR
	SET_BIT(REG_SFIOR,5);
	CLEAR_BIT(REG_SFIOR,6);
	CLEAR_BIT(REG_SFIOR,7);

#elif ADC_TRIGGER== EXTERNAL_INTERRUPT
	CLEAR_BIT(REG_SFIOR,5);
	SET_BIT(REG_SFIOR,6);
	CLEAR_BIT(REG_SFIOR,7);

#elif ADC_TRIGGER==Timer_Counter0_Compare_Match
	SET_BIT(REG_SFIOR,5);
	SET_BIT(REG_SFIOR,6);
	CLEAR_BIT(REG_SFIOR,7);

#elif ADC_TRIGGER==Timer_Counter0_Overflow
	CLEAR_BIT(REG_SFIOR,5);
	CLEAR_BIT(REG_SFIOR,6);
	SET_BIT(REG_SFIOR,7);

#elif ADC_TRIGGER==Timer_Counter_Compare_Match_B
	SET_BIT(REG_SFIOR,5);
	CLEAR_BIT(REG_SFIOR,6);
	SET_BIT(REG_SFIOR,7);

#elif ADC_TRIGGER==Timer_Counter1_Overflow
	CLEAR_BIT(REG_SFIOR,5);
	SET_BIT(REG_SFIOR,6);
	SET_BIT(REG_SFIOR,7);

#elif ADC_TRIGGER==Timer_Counter1_Capture_Event
	SET_BIT(REG_SFIOR,5);
	SET_BIT(REG_SFIOR,6);
	SET_BIT(REG_SFIOR,7);

#endif


	//ADC AUTOTREGER MODE
#if ADC_AUTOTREGER==DISABLE           //single mode
	CLEAR_BIT(REG_ADCSRA,5);

#elif ADC_AUTOTREGER ==ENABLE
	SET_BIT(REG_ADCSRA,5);
#endif


	//CHANNEL Selection
#if ADC0==ENABLE
	CLEAR_BIT(REG_ADMUX,0);
	CLEAR_BIT(REG_ADMUX,1);
	CLEAR_BIT(REG_ADMUX,2);
	CLEAR_BIT(REG_ADMUX,3);
	CLEAR_BIT(REG_ADMUX,4);

	// PIN input Direction
	CLEAR_BIT(REG_DDRA,0);
#elif ADC1==ENABLE
	SET_BIT(REG_ADMUX,0);
	CLEAR_BIT(REG_ADMUX,1);
	CLEAR_BIT(REG_ADMUX,2);
	CLEAR_BIT(REG_ADMUX,3);
	CLEAR_BIT(REG_ADMUX,4);

	// PIN input Direction
	CLEAR_BIT(REG_DDRA,1);
#elif ADC2==ENABLE
	CLEAR_BIT(REG_ADMUX,0);
	SET_BIT(REG_ADMUX,1);
	CLEAR_BIT(REG_ADMUX,2);
	CLEAR_BIT(REG_ADMUX,3);
	CLEAR_BIT(REG_ADMUX,4);

	// PIN input Direction
	CLEAR_BIT(REG_DDRA,2);

#elif ADC3==ENABLE
	SET_BIT(REG_ADMUX,0);
	SET_BIT(REG_ADMUX,1);
	CLEAR_BIT(REG_ADMUX,2);
	CLEAR_BIT(REG_ADMUX,3);
	CLEAR_BIT(REG_ADMUX,4);

	// PIN input Direction
	CLEAR_BIT(REG_DDRA,3);

#elif ADC4==ENABLE
	CLEAR_BIT(REG_ADMUX,0);
	CLEAR_BIT(REG_ADMUX,1);
	SET_BIT(REG_ADMUX,2);
	CLEAR_BIT(REG_ADMUX,3);
	CLEAR_BIT(REG_ADMUX,4);

	// PIN input Direction
	CLEAR_BIT(REG_DDRA,4);

#elif ADC5==ENABLE
	SET_BIT(REG_ADMUX,0);
	CLEAR_BIT(REG_ADMUX,1);
	SET_BIT(REG_ADMUX,2);
	CLEAR_BIT(REG_ADMUX,3);
	CLEAR_BIT(REG_ADMUX,4);

	// PIN input Direction
	CLEAR_BIT(REG_DDRA,5);

#elif ADC6==ENABLE
	CLEAR_BIT(REG_ADMUX,0);
	SET_BIT(REG_ADMUX,1);
	SET_BIT(REG_ADMUX,2);
	CLEAR_BIT(REG_ADMUX,3);
	CLEAR_BIT(REG_ADMUX,4);

	// PIN input Direction
	CLEAR_BIT(REG_DDRA,6);

#elif ADC7==ENABLE
	SET_BIT(REG_ADMUX,0);
	SET_BIT(REG_ADMUX,1);
	SET_BIT(REG_ADMUX,2);
	CLEAR_BIT(REG_ADMUX,3);
	CLEAR_BIT(REG_ADMUX,4);

	// PIN input Direction
	CLEAR_BIT(REG_DDRA,7);


#endif


	// Diferential Gain With OPAMP
#if DIFFERENTIAL == ENABLE

	// pin_0 -ve and pin_0 +ve gain 10
#if DADC00==ENABLE
	CLEAR_BIT(REG_ADMUX,0);
	CLEAR_BIT(REG_ADMUX,1);
	CLEAR_BIT(REG_ADMUX,2);
	SET_BIT(REG_ADMUX,3);
	CLEAR_BIT(REG_ADMUX,4);

	// PIN input Direction
	CLEAR_BIT(REG_DDRA,0);

	// pin_0 -ve and pin_1 +ve gain 10
#elif DADC01==ENABLE
	SET_BIT(REG_ADMUX,0);
	CLEAR_BIT(REG_ADMUX,1);
	CLEAR_BIT(REG_ADMUX,2);
	SET_BIT(REG_ADMUX,3);
	CLEAR_BIT(REG_ADMUX,4);

	// PIN input Direction
	CLEAR_BIT(REG_DDRA,0);
	CLEAR_BIT(REG_DDRA,1);



#endif

#endif

	//prescaling
#if PRESCALING==128
	SET_BIT(REG_ADCSRA,0);
	SET_BIT(REG_ADCSRA,1);
	SET_BIT(REG_ADCSRA,2);

#elif PRESCALING==64
	CLEAR_BIT(REG_ADCSRA,0);
	SET_BIT(REG_ADCSRA,1);
	SET_BIT(REG_ADCSRA,2);

#elif PRESCALING==32
	SET_BIT(REG_ADCSRA,0);
	CLEAR_BIT(REG_ADCSRA,1);
	SET_BIT(REG_ADCSRA,2);

#elif PRESCALING==16
	CLEAR_BIT(REG_ADCSRA,0);
	CLEAR_BIT(REG_ADCSRA,1);
	SET_BIT(REG_ADCSRA,2);

#elif PRESCALING==8
	SET_BIT(REG_ADCSRA,0);
	SET_BIT(REG_ADCSRA,1);
	CLEAR_BIT(REG_ADCSRA,2);

#elif PRESCALING==4
	CLEAR_BIT(REG_ADCSRA,0);
	SET_BIT(REG_ADCSRA,1);
	CLEAR_BIT(REG_ADCSRA,2);

#elif PRESCALING==2
	SET_BIT(REG_ADCSRA,0);
	CLEAR_BIT(REG_ADCSRA,1);
	CLEAR_BIT(REG_ADCSRA,2);

#elif PRESCALING==1
	CLEAR_BIT(REG_ADCSRA,0);
	CLEAR_BIT(REG_ADCSRA,1);
	CLEAR_BIT(REG_ADCSRA,2);



#endif

}



// READ Digital Value

int Adc_Read(void)
{
	u16 x = 0;

	// start conversion
	SET_BIT(REG_ADCSRA,6);
	while((GET_BIT(REG_ADCSRA,4))==0)
	{

	}
	SET_BIT(REG_ADCSRA,4);

	x=GET_REGISTER(ADCL);

	x=x|(GET_REGISTER(ADCH)<<8);

	return x ;
}


